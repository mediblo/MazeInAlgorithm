<head>
	<style>
		.impotant {
		    color: red;
		    font-weight: bold;
		}
</style>
</head>

# 3 계획 [ Planning ]
### 3.1 계획의 이해
- 계획의 역할
	- 계획을 제대로 세우지 않고 수행하는 SW 개발은 <b>일정 지연, 비용 초과, 품질 저하</b>라는 결과를 낳게 됨

---
### 3.2 문제 정의
- 문제 정의
	- 문제를 정의하려면 개발하고자 하는 영역의 배경 지식이 필요
	- 유사한 프로젝트를 개발한 경험이 있느 분석가가 참여하는 것이 도움이 됨
	- 문제를 파악하기 위해 현재 운영 중인 시스템을 사용함
	- 실무 담당자와 면담해 자료를 수집한 후 면밀히 분석해보는 것이 필요

---
### 3.3 타당성 분석 [ 표로 제작 ]
- 경제적 타당성
	-	경영자 입자엥서 의사결정을 하는 데 매우 중요한 요소
	- 시장 분석을 통해 시장성을 확인
	- 경제적 타당성 분석으로 투자 효율성과 시장성을 검증한 후 개발 여부를 판단

- 기술적 타당성
	- 사용자가 요구하는 프로젝트가 최신 기술이 필요하다면 기술적 타당성을 먼저 검토
	- 요구하는 기술을 회사가 가지고 있는지 확인
	- 부족하다면 필요한 기술을 갖고 있는 SW 개발자를 채용하거나 외주 개발로 해결

- 법적 타당성
	-	오픈소스는 SW 개발에서 분쟁 발생 소지가 높음
	- SW 개발에서 오픈소스를 사용하는 것은 비용 절감 측면에서 매우 효율적
	- 오픈소스는 원시 코드가 개방되어 있다는 것이지 아무렇게나 가져다 사용할 수 있는 것은 아님
	- 법적인 문제가 발생하지 않으려면 오픈소스를 사용 할 때 어디까지 무료로 사용할 수 있는지 확인해야 함

---
### 3.4 개발 비용 산정
- 개발 비용 산정의 어려움
	- SW 가격은 근거를 명확히 제시하기 어려워 사용자도 받아들이기가 쉽지 않음
	- 개발 프로세스가 다양하기 때문에 표준화나 자동화가 어려워 개발 프로세스에 따라 생산성이나 품질이 생산성이나 품질이 서로 다를 수 있음

- 개발 비용에 영향을 주는 요소 [ 표로 제작 ]
	-	프로그래머 자질
		- 초급 프로그래머와 경험이 많은 프로그래머의 생산성에는 큰 차이가 있음
	- SW 복잡도
		- 브룩스의 법칙 : App을 개발하는 것보다 유틸리티를 개발하는 것이 세 배 어렵고, 보다 시스템 프로그램을 개발하는 것이 세 배 어렵다. [ App < Utility < System Program ]
	- SW 크기
		- 개발하려는 SW의 규모가 크면 개발 인력과 개발 기간도 늘고 복잡도도 더 커짐
	- 가용 시간
		- 관리자의 잘못된 생각 중 하나가 개발 기간을 단축하려면 인력과 자원을 늘리면 된다는 것 [ バカ ]
		- 보엠 : 정상적인 계획에서 <b>최대 75%</b>가 줄일 수 있는 한계
	- 요구되는 신뢰도 수준
		- 사고나 오류 발생 시 재산에 큰 손실을 끼치거나, 인명 피해가 발생할 수 있는 SW들은 개발 시 높은 신뢰도를 요구
	- 기술 수준
		- SW 개발 시 고급 언어를 사용하면 저수준 언어를 사용할 때보다 프로그래머의 생산성이 5 - 10배 높아짐

---
### 3.5 비용 산정 기법 1 : 하향식 산정 기법
- 전문가 판단 기법 [ 눈대중과 경험으로 얼마인가 ]
	- 경험이 많은 여러 전문가가 프로젝트를 수행하는 데 비용이 어느 정도 들어가는지 평가한 금액을 개발 비용으로 산정
	- 경험이 많은 전문가가 판단을 내린 만큼 신뢰성이 있고 편리하다는 장점
	- 짧은 시간에 개발비를 산정하거나 입창에 응해야 하는 경우 많이 사용
	- 수학적 계산에 의해 산정하지 않고 경험에만 의존할 경우 부정확할 수 있음

- 델파이 기법 [ 고요한 업 앤 다운 눈치게임 ]
	- 전문가의 경험을 중요시해 비용을 산정하는 것은 같으나 전문가들의 편견이나 분위기에 영향을 받지 않도록 조정자를 둠
	- 여러 전문가가 모여 각자의 의견대로 비용을 산정 후 결과를 공유하고 의견을 조율하여 개발 비용을 산정
		1. 조정자는 전문가가 모여 비용 산정을 하는 회의에서 간사 역할을 수행 [간사 = 중재자]
		2. 전문가는 자료를 검토, 필요하다면 의견을 나눌 수 있음
		3. 각자 비용을 산정, 이때 계산된 결과를 조정자에게 익명으로 제출
		4. 조정자는 제출한 자료를 요약 정리
		5. 제출한 자료에서 산정 내용에 차이가 크면 이 문제를 해결하기 위해 회의 소집
		6. 전문가는 다시 익명으로 비용 산정 작업 실시
		[ 그림 3 - 4 ]

---
### 3.6 비용 산정 기법 2 : 상향식 산정 기법
- 원시코드 라인 수 [LOC : Line Of Code] 산정 기법
	- SW 각 기능의 LOC의 비관치, 낙관치, 중간치를 측정해서 예측치를 구하고 이를 이용해 노력, 개발 비용, 개발 기간, 생산성 등의 비용을 산정하는 기법
		- 노력[MM : Man/Month] = MM * 개발 기간 = 추정 LOC / 생산성
		- 생산성 = LOC / MM
		- 개발 비용 W = MM * 단위 비용 [1인당 월평균 인건비]
		- 개발기간 TDEV = MM / 참여 인원
	- Ex)
		- SW 개발 기간은 12개월, 5명의 개발자가 12개월, 7명의 개발자가 5개월 동안 참여한다면 이 SW의 개발 노력[MM]은?  
		&rarr; (5*12)+(7*5) = 60MM + 35MM = 95MM
		- LOC기법에 의해 예측한 총 라인이 5만 라인, 개발자가 10명 참여, 개발자들의 평균 생산성이 500라인이라면 개발 기간은?  
		&rarr; 50000[LOC] / 500[생산성] / 10[人] = 100/10 = 10M

- 개발 단계별 노력 산정 기법
	- 각 기능을 구현하는 데 필요한 M/M를 SW 개발 생명주기의 각 단계에 적용해 단계별로 산정
	- 요구분석 MM + 설게 MM + 구현 MM + 시험 MM + 배포 및 유지보수 MM

---
### 3.7 비용 산정 기법 3 : 수학적 산정 기법
- COCOMO I 방법 [★★★☆☆]
	- 개요
		- SW 개발 비용을 산정할 때 원시 코드의 크기, 즉 라인 수를 중심에 두는 방법
		- 먼저 완성될 SW의 크기[LOC]를 추정하고 이를 준비된 식에 대입해 개발에 필요한 MM을 예측
	- 고려 사항
		- 프로그램 유형에 따른 가중치를 두어야 함
		- 보정을 해야 함 : SW를 <b>제품, 컴퓨터, 개발자, 프로젝트</b>의 4가지 특성에 따라 총 15가지로 분류한 후 인건비를 더 보정
	- 가중치 반영 [표]
		- 단순형 프로젝트 [Organic]
			-복잡도와 난이도가 비교적 높지 않은 업무용 SW가 이에 해당
			- 중소 규모 정도, 크기는 50KDSI 이하
		- 중간형 프로젝트 [Semi-detached]
			- 일반 업무용 SW보다 복잡하고 규모가 더 큰 OS, DB 관리 프로그램 등이 이에 해당
			- 규모나 복잡도가 중간 정도, 크기는 300KDSI 이하
		- 내장, 복잡형 프로젝트 [Embedded]
			- 자동화 기기나 전자 제품과 같은 HW와 밀접하게 관련 있는 내장형 SW가 이에 해당
			- 크기는 300KDSI 이상
	- 개발 인건비 초기 예측
		- 제시하는 공식을 사용하면 개발 인건비[MM]의 초기 예측 값을 계산
		- 규모가 같은 SW일 경우 기본형 < 중간형 < 내장형 순으로 MM이 더 많이 필요
		[ 표 3-1 | 그림 3-5 ]
	- 보정 계수 반영
		- 노력 조정 수치[EAF] : 보정에 사용하는 값, 필요한 각 항목별 승수 값을 모두 곱한 값
		- 15개의 세무 항목에 따른 보정 값을 모두 정해 놓음
		[ 표 3-3 | 3-4 ]
	- 총 개발 기간 산정
		- 보엠이 제시하는 총 개발 기간을 계산할 떄는 개발할 sW 유형에 상관없이 모두 동일한 상수[2.5] 값을 곱함
		- 개발 기간은 SW 유형과 상관없음

- COCOMO II 방법 [★★★★☆]
	- I 단점
		- 개발 초기에 LOC 추정이 어려움, 옛 방식, 프로젝트 진행 정도에 따른 3단계 산정 모델 제안
	- 애플리케이션 합성 모델
		- 1단계에서는 <span class = "impotant">입출력 화면 중심의 사용자 인터페이스 개수</span>등을 계산해 아래와 같이<span class = "impotant">객체 점수</span>를 산출  
		&rarr; 기능점수법과 유사하나 데이터 점수 반영하지 않음
		- 개발 범위에 속한 객체[입출력 화면 등]를 찾음
		- 객체가 제공하는 기능의 복잡도를 3가지[단순, 보통, 복잡]로 분류
		- 객체의 개수에 가중치[단순, 보통, 복잡]를 부여해 결과값을 산출
	- 초기 설계 모델
		- 2단계는 초기 설계 단계에서 예측 값을 구함
		- 초기 설계 단계쯤 되면 1단계보다는 시스템의 구조와 기능을 좀 더 상세히 알 수 있어 1단계보다 더욱 정확한 예측이 가능
		- 다음에 소개되는 <span class = "impotant">기능점수</span> 방법을 사용하여 기능 점수를 구함
	- 구조  설계 이후 모델
		- 3단계에서는 이미 기능 점수가 나왔기 때문에 노력을 추정하는 게 어렵지 않음
		- <span class = "impotant">기능 점수를 바탕으로 한 LOC를 추정</span>해 SW 규모를 산정
		- COCOMO II에 적용되는 기본 공식
			- $E = b * S^c * 4(X)$
			- $b * S^c$ : 기초 소요 노력 예측값
			- $m(X)$ : 비용 승수의 벡터

- 기능 점수 산정 방법
	-	 개요
		- 사용자 관점에서 SW의 기능을 정량화해 SW 개발 비용 산정에 활용
		- SW의 기능이 얼마나 복잡한가를 상대적인 점수로 표현
		- 사무용 또는 관리용 SW에서 매우 유용한 방법
	- 용도
		- SW 개발 시 비용을 산정하는 데 사용
		- SW 유지보수 비용을 산정하는 데 사용
		- SW 개발 시 필요한 자원을 산정하는 데 사용
	- 특징
		- SW 규모를 측정하는 방법
		- 기능적 요구사항이 중심이 되는 측정 방법
		- SW의 요구사항 복잡도를 측정
		- 구현 관점[물리적 파일, 화면, 프로그램 수]이 아닌 사용자 관점의 요구 기능을 정량적으로 산정
		- 측정의 일관성을 유지하기 위해 개발 기술, 개발 방법, 품질 수준 등은 고려하지 않음
		- SW 개발에 사용하는 언어와 무관
		- SW 개발 생명주기의 전체 단계에서 사용 가능
	- 구분
		- 기능 점수의 기준이 되는 SW 기능은 크게 데이터 기능과 트랜잭션으로 구분
		- <src img = https://imgur.com/AmXgMwA.png>
		- SW 사업 대가산정 가이드에서 제시하는 구분법
		- <src img = https://imgur.com/p07UgVg.png>
	- 장점
		- 사용자의 요구사항만으로 기능을 추출해 측정
		- 객관적인 요구사항만으로 측정
		- 모든 개발 단계에서 사용
	- 단점
		- 높은 분석 능력 필요
		- 기능 점수 전문가 필요
		- 내부 로직 위주의 SW에는 다소 부적합
		- 개발 공수보다 개발 규모 측정에 적합

- 간이 기능 점수법을 이용한 기능 점수 산정 방법
	- 간이 기능 점수법
		- 프로젝트 초기 단계에서 각 기능의 요소를 모르는 경우에 평균 복잡도 가중치를 사용해 SW 기능의 크기를 측정
		- <src img = https://imgur.com/iOTnJqc.png>
		- 평균 복잡도 가중치
			- 과거에 수행한 SW의 기능 점수 산정 결과를 분석해 5가지 유형에 적용된 복잡도를 계산한 가중치의 평균값
			- 사업 초기에는 기능 점수를 산정할 수 있을 만큼 자료가 충분하지 않으므로 평균 복잡도 가중치에 의존해 기능 점수를 산정
			- 정상적인 기능 점수 산정 결과를 검증할 때도 평균 복잡도 가중치를 적용해 기능 점수를 산정

|유형|ILF|EIF|EI|EO|EQ|
|---|---|---|---|---|---|
|가중치|7.5|5.4|4.0|5.2|3.9|

-	- 측정 유형 결정
		- 개발 프로젝트 기능 점수 [ 개발 규모 측정 ]
			- 프로젝트가 완료되어 최초 설치했을 때의 기능 크기를 산정하는 것
			- 프로젝트에서 사용자를 위해 제공된 모든 기능을 측정
		- 개선 프로젝트 기능 점수 [ 변경 규모 측정 ]
			- 사용 중인 SW에 변경이 발생했을 때 변경된 부분의 기능을 측정
			- 완료된 프로젝트에서 추가, 수정, 삭제된 부분만 그 크기를 측정
		- 애플리케이션 기능 점수 [ 응용 규모 측정 ]
			- 애플리케이션 기능 점수는 현재 운용 중인 애플리케이션의 기능을 측정
			- 개발 프로젝트 기능 점수에 개선 프로젝트 기능 점수까지 포함
	- 측정 범위와 애플리케이션 경계 설정
		- 측정 범위에 포함될 요소[서브 시스템]의 식별
			- 측정 범위 : 기능 점수를 측정하고자 하는 대상
	- 애플리케이션 경계
		- 애플리케이션 경계 : 기능 점수를 계산하는 대상을 제외한 다른 애플리케이션이나 외부 사용자를 구분한 경계
		- 경계를 지을 때 주의할 점은 사용자 관점에서 구분해야함 <b>[ 개발자 관점에서 구분 X ]</b>
		- 애플리케이션의 경계도 적당해야 함
		- <src img = https://imgur.com/vKDT4ML.png>
	- 데이터 기능 점수 계산
		- ILF의 개수와 EIF의 개수를 계산해 각각의 평균 복잡도에 따라 데이터 기능 점수가 결정
		- <src img = https://imgur.com/u49Mx2Z.png>
		- 내부 논리 파일
			- 사용자가 CURD를 하기 위한 대상으로, DB에 존재하는 데이터 모임[정보]
			- DB의 정보들은 기능 점수 측정 대상으로 애플리케이션 내부에서 파일로 유지
		- 외부 연계 파일
			- 측정 대상 애플리케이션에서는 참조만 하고 다른 애플리케이션에서 유지되는 파일
		- ILF : 이번 프로젝트에서 생성해 관리하는 데이터
		- EIF : 이번 프로젝트에서 참조하는 데이터
		- <src img = https://imgur.com/SYPTRCQ.png>
		- 데이터 기능 점수는 LIF의 개수와 EIF의 개수에 각각의 평균 복잡도[가중치]를 곱해 계산 [ ★★★ ]
			- 점수 = {(ILF 개수 * 7.5) + (EIF 개수 * 5.4)}
			- 7.5와 5.4는 각각 파일의 평균 복잡도
	- 트랜잭션 기능 점수 계산
		- 기능 점수에서 트랜잭션 기능의 복잡도는 입력, 출력, 조회의 개수로 결정
			- 트랜잭션 기능 점수 {(EI 개수 * 4.0) + (EO 개수 * 5.2) + (EQ 개수 * 3.9)}
			- 4.0, 5.2, 3.9는 각각 외부 입력, 외부 출력, 외부 조회의 평균 복잡도
		- EI : DB에 데이터를 등록하거나 수정, 삭제하는 것 [ 학생정보 등록, 수정, 삭제 ]
		- EO : 계산하는 로직을 거쳐 데이터나 제어 정보를 사용자에게 보여주는 기능 [ 학생 학점 조회 ]
		- EQ : 로직이 필요 없고 DB에 존재하는 데이터를 찾아 그래도 표시만 해주는 기능 [ 학생 주소 검색, 학생정보 조회 ]
		- <src img = https://imgur.com/PnPouu8.png>
	- 미조정 기능 점수 계산 [ UFP ]
		- 앞에서 구한 데이터 기능 점수와 트랜잭션 기능 점수를 합한 값
		- 단순히 기능적인 요구사항에 대해서만 계산했지, 여러 가지 특성 대한 고려를 하지 않음
		- <src img = https://imgur.com/2y9l3l2.png>
	- 보정 전 개발 원가 계산
		- 미조정 기능 점수에 기능 점수당 단가를 곱해 계산
			- 보정 전 개발 원가 = 미조정 기능 점수 * 기능 점수당 단가
			- 분석 | 설계와 구현 | 테스트를 구분해 별도의 사업으로 진행 시 복잡도 가중치와 가중치에 따른 단계별 단가를 적용

|단계|분석|설계|구현|테스트|합계|
|---|---|---|---|---|---|
|평균 복잡도 가중치|0.19|0.24|0.32|0.25|1.00|
|단가|105,092원|132,747원|176,996원|138,279원|553,114원|
-	- 보정 계수
		- 보정 계수의 필요성
			- 규모와 유형도 다양하고, 연계 복잡성 수준, 성능요구 수준, 운영 환경 호환성, 보안성 수준이 프로젝트의 특정에 따라 다름
			- 실제 개발 비용에 영향을 미치므로 이들에 대 해 보정 계수를 정하고 이를 반영해 보정한 후 개발 원가를 구해야 함
		- 규모 보정 계수
			- 기능 점수가 500FP 미만이면 규모 보정 계수 1.28을, 3,000FP 초과이면 1.153을 적용
			- 규모 보정 계수 = $0.4057 * (log_e(기능점수)-7.1978)^2 + 0.8878$  
			&rarr; [ 단, 500FP 미만 시 1.2800, 3000FP 초과 시 1.1530을 적용 ]
		- 애플리케이션 복잡도 보정 계수
			- 사용자가 요구하는 SW가 복잡하다면 어려운 만큼의 보정 계수를 적용
			- 애플리케이션의 복잡도는 연계 복잡성 수준, 성능요구 수준, 운영 환경 호환성, 보안성 수준으로 나뉨
			- 연계 복잡성 수준
				- 연계 복잡성 수준은 연계 기관 수에 따른 보정 계수를 적용
				- <src img = https://imgur.com/2g6zfrH.png>
			- 성능요구 수준
				- 개발하려는 SW에 대해 사용자가 빠른 응답시간 또는 높은 처리용을 요구한다면 SW의 복잡도는 높아짐
				- <src img = https://imgur.com/hOpDZax.png>
			- 운영 환경 호환성
				- 개발이 완료되어 설치할 때의 운영 환경[HW/SW]이 단순하지 않고 다음 표처럼 다양하다면 이를 보정 계수로 반영
				<src img = https://imgur.com/xSYUPZb.png>
			- 보안성 수준
				- 보안에 대한 요구가 많을수록 복잡도는 높아지고 이를 다음 표처럼 보정 계수로 반영
				<src img = https://imgur.com/0bEqd7e.png>
	- 보정 후 개발 원가 계산
		- 보정 후 개발 원가 = 보정 전 개발 원가 * ( 규모 보정 계수 * 연계 복잡성 수준 보정 계수 * 성능요구 수준 보정 계수 * 운영 환경 호환성 보정 계수 * 보안성 수준 보정 계수 )
		- 5가지 보정 계수의 값을 구했다면 이 값을 적용해 보정한 후 개발 원가를 계산할 수 있음

<src img = https://imgur.com/e1GLWhx.png>
<src img = https://imgur.com/d0XCTHV.png>

---
### 3.8 일정 계획
- 일정 계획이란?
	- SW를 개발하기 위해 어떤 작업이 필요한지 찾은 후, 이를 진행할 순서를 결정하거나 주어진 개발 기간에 소작업의 개발 기간 및 그들 간의 순서, 필요한 자원 등과 같은 일정을 계획하는 것 [ 표 3- 17 ]

- 일정 계획의 시작 : 작업 분할 구조도[WBS]
	- WBS
		- 프로젝트 목표를 달성하는 데 필요한 활동과 업무를 세분화하는 작업
		- 작업 패키지 : 계층 구조에서 최하위에 있는 항목, 해당 업무의 담당자를 할당할 수 있을 정도로 작게 나눔
	- WBS의 용도와 장점
		- 사용자와 개발자의 의사소통 도구로 사용
		- 프로젝트업무 내역을 가시화할 수 있어 관리가 용이
		- 프로젝트 팀원의 책임과 역할이 분명
		- 필요 인력과 일정 게획을 세우는 데 기초로 활용
		- 개발비 산정 시 기초로 활용
		- 성과 측정 및 조정 시 기준선으로 활용할 수 있음 [ 그림 3-12 ]

- 일정 계획 기법 1 : 네트워크 차트
	- 네트워크 차트 [ PERT/CPM ]
		- 네트워크 차트의 개요
			-	WBS의 작업 순서, 소요 기간 등을 네트워크 형태의 그래프로 표현한 후 일의 중요도와 일정 관리를 명확히 하는 데 사용
			- 전체 작업 일정을 세분화해 지연을 사전에 예방할 수 있고, 개발 기간 단축에 활용해 일정을 효율적으로 관리할 수 있음
			- 크게 PERT와 CPM 네트워크가 사용됨
			- 유사성과 상호 장단점 때문에 PERT/CPM이라 해 두 기법을 혼합한 방법을 사용하기도 함
		- PERT [ Program Evaluation Review Technique, 퍼트 ]
			- 프로그램을 평가하고 검토하는 프로젝트 관리 기법
			- 프로젝트 진행 상황을 통계적인 방법으로 파악하고 이를 통해 일정 계획 및 통제를 할 수 있도록 고안
		- CPM [ Critical Path Method ] [ ACM CRAFT..? ]
			- 미 듀퐁사에서 화학 처리 공장의 건설 계획을 조직적으로 추진하기 위해 개발
			- 건설 공사와 같이 단위 작업이 확정적 소요 시간을 갖는 프로젝트인 경우에 적합
	- CPM 작업 과정
		- CPM으로 네트워크를 그리려면 학사관리 애플리케이션을 수행하는 데 필요한 작업, 선행 작업, 작업의 소요 기간이 필요 [ 표 3-18 ]
		1. CPM 네트워크를 그림
			- 노드와 간선을 이용해 초기의 CPM 네트워크를 그림
			- 노드는 작업을, 간선은 직업들 간의 선후 의존 관계를 나타냄
			- 각 작업의 작업시간[WT]를 각 노드에 표시
			- 가장 첫 작업[A]의 ES, LS는 0로 초기화, EF, LF는 각각 0 + WT로 초기화
		2. ES 값을 구함 [ Earliest Start Time ]
			- ES : 가능한 빨리 시작할 수 있는 시간으로, 선행 작업이 완료되었을 때 해당 작업을 시작할 수 있는 가장 빠른 시점
			- ES 값을 구할 때는 맨 앞[작업 A]에서 끝 방향으로 가며 계산
			- ES에서 주의할 부분은 두 작업이 합류하는 지점의 작업 시작 시간은 두 작업이 모두 완전히 끝났을 때
			- <span class = "impotant">ES max{EFp}, EFp 는 전단계의 EF 값들의 집합</span>
		3. EF 값을 구함 [ Earliest Finish Time ]
			- EF : 가장 빠른 시작 시간[ES]으로 시작했을 때의 가장 빠른 완료 시간
			- <span class = "impotant">EF = ES + 작업 소요 시간[WT]</span>
		4. LF 값을 <span class = "impotant">먼저</span> 구함
			- LF : 가장 늦게 시작할 수 있는 시간[LF]에 시작 해 작업을 완료한 시간
			- 두 지점으로 갈라지는 곳에서는 다음 작업의 시작 시간에 영향을 주지 않고 시작할 수 있는 시간을 찾아 기입
			- 맨 뒤[M]에서 앞[A] 방향으로 계산
			- 마지막 작업의 LS = ES, LF = EF로 초기화
		5. LS 값을 구함
			- LS : 어떤 작업을 늦어도 시작해야 하는 시간, 즉 가장 늦게 시작할 수 있는 시간
			- <span class = "impotant">LS =LF - WT</span>
		6. ST 값을 구함 - 여유 시간 [ Slack Time ]
			- ST : 여유 시간, 각 작업에서 '가장 늦게 시작하는 시간'에서 '가장 빨리 시작하는 시간'을 빼면 구할 수 있음
			- 전체 작업 시간을 줄이고 싶을 때는 여유 시간이 존재하는 작업의 시간을 줄이면 됨
			- <span class = "impotant">ST = LF - EF = LS - ES</span>
		7. 임계 경로를 구함
			- 임계 경로 : 여유 시간이 없는 경로, <span class = "impotant">ST = 0 인 경로.</span>
			- 임계 경로에는 여유 시간이 없으므로 모든 일정 계획은 임계 경로에 좌우됨
			- 임계 경로에서 벗어난 활동을 수행하는 걸리는 시간이 한도 내에서 늦춰지거나 당겨 질 경우에는 전체 프로젝트 완료 시간에 변화가 없음

- 일정 계획 기법 2 : 간트 차트를 이용한 일정표 작성
	- 간트 차트
		- 프로젝트 일정 관리를 위한 바 형태의 도구
		- 프로젝트의 주요 활동을 파악한 후, 각 활동의 일정을 시작하는 시점과 끝나는 시점을 연결한 막대 모양으로 표시
		- 전체 일정을 한눈에 볼 수 있음 [ 그림 3 - 15 ]

---
### 3.9 위험 분석
- 위험 분석의 이해
	- 위험 예방
	- 도구를 사용한 위험 예방
	- 위험 예방을 위한 도구 준비

- 위험 관리 절차
	- 위험 관리
		- sw 개발에 방해가 되는 요소를 파악 [ 위험 요소 식별 ]
		- 위험 요소의 발생 확률과 영향도를 평가 [ 위험 분석 ]
		- 분석한 결과에 따라 위험 우선순위를 정해 그에 맞게 대책을 설립 [ 그림 3-19 ]
		- 위험 요소 식별
			- 발생 가능한 위험 요소에 대해 브레인스토밍해서 도출하는 방법
			- 이전에 유사한 프로젝트를 진행했을 때 발생한 위험 요소를 참조하는 방법
			- 대표적인 위험요소로는 개발자들의 이직, 요구사항의 변경 등
			- 표 3-24
		- 위험 분석
			- 위험 발생 가능성의 척도
				- 매우 낮음[<10%], 낮음[10-25%], 보통[25-50%], 높음[50-75%], 매우 높음[>75%] 등급으로 분류
				- 프로젝트 진행 중 '위험 발생 확률이 80%를 초과하면 상, 30-80%이면 중, 30% 미만이면 하'와 같이 세 단계로 분류
			- 영향력
				- 재앙, 심각함, 해결 가능함, 경미함 등으로 분류
				- 비용과 일정이 20%를 초과하면 상, 5-20%이면 중, 5%이만이면 하로 분류
			- 도출된 위험 요소에 대한 가능성과 영향력을 등급으로 나타냈다면 이를 이용해 어떤 위험이 가장 중요한지 순위를 정함 
		- 위험 계획 수립
			- 위험 게획 수립은 식별된 위험 요소의 위험을 관리하기 위해 전략을 찾는 과정
			- 이 과정에서는 특히 위험을 처리하는 위험 대응 방안을 잘 세워야 함
		- 위험 감시
			- 식별된 위험 요소의 발생 확률과 변화 등을 관리
			- 예측한 위험 요소가 실제로 얼마나 발생했는지, 위험 대응 방안이 실제로 위험아ㅣ 발생했을 때 적절했는지 등을 평가
			- 앞으로 유사한 프로젝트를 진행할 때 참고할 수 있도록 개발사 내의 DB에 기록해 놓아야 함
---
### 부록 : 프로젝트 계획 단계에서의 그 밖의 주요 작업
- 프로젝트 조직 구성
	- 개발 계획에 따른 참여 인원 업무 할당
	- 참여 인원에 따라 일정이 단축되거나 늘어질 수 있음
- 프로젝트 자원 및 환경 계획
	- SW 개발 및 운영에 필요한 서버, 컴퓨터, DB, 사무공간 등 개발 환경 게획
- 보안 계획
	- 프로젝트 진행 과정에서의 정보 보안 관리 게획
- 테스트 마스터 플랜
	- 개발 과정에서 어떤 절차와 방법, 도구로 테스트를 진행할 지에 대한 개괄적인 계획
	