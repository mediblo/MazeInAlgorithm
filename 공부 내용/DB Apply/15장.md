# 15장 Query Processing [ 질의 처리 ]
> Sorting [정렬]부터 시작함

---
### 정렬
> 데이터[레코드, 튜플]를 특정한 키[필드][이를 **정렬 키** 또는 **정렬 필드**라 함] 기준으로 순서대로 배치하는 것

**정렬의 분류**
- 내부 정렬[Internal Sorting] : 데이터 구조
  + 전체 데이터를 메모리에 저장하여 정렬하는 방법
  + 데이터 구조에서의 정렬 방법[삽입, 선택, 합병, 퀵, 힙..]
  + 파일 구조에서도 적용 가능 : 단 데이터 파일의 크기가 작은 경우
- 외부 정렬[External Sorting] : 파일 구조
  + 전체 데이터를 메모리에 저장할 수 없는 경우에 정렬하는 방법
  + DBS에서 정렬하는 방법

**DBMS에서 정렬이 필요한 경우**
- 릴레이션[데이터 파일]에서 인덱스를 구축하는 경우
- 다음 경우 연산을 포함하는 SQL 검색 시에
  + distinct
  + group by or order by
  + 집합 연산
  + 조인 연산

**\-** 정렬된 순서로 릴레이션을 읽기 위해서 보조 인덱스를 이용하는 경우 '대량의 디스크 블록 IO 발생'라는 문제점이 발생됨  
**\-** 메모리가 맞지않는 릴레이션을 위한 '외부 합병 정렬'은 아주 좋은 방법  

**외부 합병 정렬 방법**
> 메모리 크기 = M

- 정렬 단계
    1. 정렬된 런을 만듬
    1. i = 1
    1. while len(M) != i:
        1. 메모리에 들어가 있는 M개의 릴레이션 블록 읽기
        1. 메모리 내 블록 정렬
        1. 정렬된 데이터를 런R<sub>i</sub>에 작성, i++  
        (최종 i의 값은 N이 됨)
- 병합 단계 [ N-way 병합 ] [ N < M ]
    1. 런을 병합함
    1. N개의 블록의 메모리를 사용하여 버퍼를 런에 입력
    1. 1개의 블록을 사용하여 버퍼를 출력 
    1. 각 런의 첫 번째 블록을 해당 버퍼 페이지에 읽어들임
    1. while input_buffer != empty:
        1. 모든 버퍼 페이지 중에서 첫 번째 레코드(정렬 순서)를 선택
        1. 레코드를 출력 버퍼에 기입
        1. 출력 버퍼가 가득 차면 디스크에 기입
        1. 레코드를 입력 버퍼 페이지에서 삭제
        1. 버퍼 페이지가 비어 있으면 런의 다음 블록(있는 경우)을 버퍼에 읽어들임